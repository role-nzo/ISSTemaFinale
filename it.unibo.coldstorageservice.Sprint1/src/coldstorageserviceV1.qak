System coldstorageservice

Request engage        : engage(OWNER) //FATTO
Reply   engagedone    : engagedone(ARG) //FATTO
Reply   engagerefused : engagerefused(ARG) //FATTO

Dispatch disengage    : disengage(ARG) //FATTO

Dispatch setrobotstate: setpos(X,Y,D)
Dispatch setdirection : dir( D )  //D =up|down!left|right

Request  doplan   : doplan( PATH, OWNER, STEPTIME )
Reply doplandone  : doplandone( ARG )
Reply doplanfailed  : doplanfailed( PLANDONE, PLANTODO )


Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG)
Reply moverobotfailed:  moverobotfailed(ARG)


Dispatch goMoveToIndoor   : goMoveToIndoor(_) //FATTO
Dispatch goMoveToColdRoom : goMoveToColdRoom(_) //FATTO
Dispatch goMoveToHome     : goMoveToHome(_) //FATTO


//Ottenimento del ticket
Request newticket		: newticket( FW )
Reply newticketaccepted : newticketaccepted( TICKET )
Reply newticketrefused  : newticketrefused( REASON )


//Show ticket per rilascio merce
Request ticketrequest : ticketrequest( TICKET, FW )
Reply ticketaccepted  : ticketaccepted( MESSAGE )
Reply ticketrejected  : ticketrejected( REASON )


Request loaddone	: loaddone(FW)
Reply chargetaken	: chargetaken(MESSAGE)
Reply chargefailure : chargefailure(REASON)


Context ctxbasicrobot 		  ip [host="127.0.0.1" port=8020]
Context ctxcoldstorageservice ip [host="localhost" port=8022]
//Context ctxfridgetruck 		  ip [host="192.168.10.122" port=8023] //Eliminare -> funziona solo con 3 contesti

ExternalQActor basicrobot context ctxbasicrobot

/*
 * TO-DO
 * Scrivere sullo sprint i ragionamenti fatti per raggiungere il modello
 * Scrivere perchè coldRoom POJO (non ha la necessità di inviare/ricevere messaggi direttamente)
 * Problema del load-time lungo -> perchè abbiamo scelto più messaggi per la showTicketRequest
 * 
 * PROBLEMA DRIVER MALEVOLO: come riconoscere il truck
 * 		--> non necessario
 * PROBLEMA CODA SHOW TICKET: come gestire il caso di più show ticket request
 * 		--> da testare
 * 
 * Nell'analisi del problema indicare:
 *  - Struttura ticket: idTruck,
 *  -  Perchè coldRoom come POJO e non Attore
 *  - Come abbiamo risolto problema del load time lungo
 *  - Problema carico maggiore rispetto al peso trasportabile
 * 
 */


QActor transporttrolley context ctxcoldstorageservice{
	//TODO: gestire il move failed 
	
	State s0 initial {
		println("transporttrolley starts") color blue
		//Acquisizione del basicrobot
    	request basicrobot -m engage : engage(transporttrolley)	
	}
	Transition t0 whenReply engagedone    -> init
                  whenReply engagerefused -> waitrobotfree
                  
    State waitrobotfree{
		println("transporttrolley engage refused") color red
	}
	
	State init{
		println("transporttrolley init") color red
	} Goto waitcoldstorageservicerequest
	
	
	State waitcoldstorageservicerequest {
	  println("$name | waiting the client request...")
	}
	Transition t0 whenMsg goMoveToIndoor   -> elabMoveIndoor
				  whenMsg goMoveToColdRoom -> elabMoveColdRoom
				  whenMsg goMoveToHome     -> elabMoveHome
	 
	State elabMoveIndoor {	
		printCurrentMessage color blue	
		
		request basicrobot -m moverobot	: moverobot(0, 4)
	}
	Transition t0 whenReply moverobotdone -> planFinishIndoor
				  whenReply moverobotfailed -> waitcoldstorageservicerequest
	
	State elabMoveColdRoom {
		printCurrentMessage color blue
        
        request basicrobot -m moverobot	: moverobot(4, 3)	
	}
	Transition t0 whenReply moverobotdone -> planFinishColdRoom
				  whenReply moverobotfailed -> waitcoldstorageservicerequest
	
	State elabMoveHome {
		printCurrentMessage color blue

        request basicrobot -m moverobot	: moverobot(0, 0)		
	}
	Transition t0 whenReply moverobotdone -> planFinishHome
				  whenReply moverobotfailed -> waitcoldstorageservicerequest

	
	State stopped {
		
	}
	
	State resumed {
		
	}
	
	State planFinishIndoor {
		//prendere il carico
	} Goto waitcoldstorageservicerequest
	
	State planFinishColdRoom {
		//depositare il carico
	} Goto waitcoldstorageservicerequest
	
	State planFinishHome {
		println("$name | at home")
		delay 1000
		
		//NON FUNZIONA
		//forward basicrobot -m setdirection : dir(down)
	    
	    
		//aspettare altre richieste
	} Goto waitcoldstorageservicerequest
		
}


QActor coldstorageservice context ctxcoldstorageservice{ //Registrata a coldRoom
	[# val ticketList = listOf<Ticket>() 
	   val currentWeight = 0 
	   val maxWeight = 100
	#]
	//currentWeight rappresenta il peso virtuale corrente della coldRoom che considera anche i ticket ancora in coda
	
	State s0 initial{
		println("coldstorageservice starts") color green
		
		forward transporttrolley -m goMoveToIndoor   : goMoveToIndoor(0) 
		forward transporttrolley -m goMoveToColdRoom : goMoveToColdRoom(0) 
		forward transporttrolley -m goMoveToHome     : goMoveToHome(0) 
		
		forward transporttrolley -m goMoveToIndoor   : goMoveToIndoor(0) 
		forward transporttrolley -m goMoveToColdRoom : goMoveToColdRoom(0) 
		forward transporttrolley -m goMoveToHome     : goMoveToHome(0) 
	}
	//Goto waitclientrequest
	
	
	State waitclientrequest{
	  
	  println("$name | waiting the client request...")
	  
	}
	Transition t0 whenRequest newticket -> elabNewTicket
				  whenRequest ticketrequest  -> elabTicketRequest
				  whenRequest loaddone -> elabLoadDone
	
	State elabNewTicket{
		[#
			val ticket = Ticket("aaa", java.time.Instant.now().epochSecond, 3)
		#]
		//Verifica id univoco, il ticket verrà aggiunto ad una lista di ticket
		replyTo newticket with newticketaccepted:newticketaccepted(aaa)
		
		
	}
	Goto waitclientrequest
	
	State elabTicketRequest{
		
		onMsg( ticketrequest : ticketrequest( TICKET, FW )){
	    	[# val currentTime = java.time.Instant.now().epochSecond 
		   	   val idTicket = payloadArg(0)
		   	   
		   	   for (ticket in ticketList){
		   	   	  //ciclo for per trovare il biglietto del driver nella lista
		   	   }
		   	   
		   	   //val ticketValid = (currentTime - ticket.creationTime) > TIMEMAX
		   	   if(true /*ticketValid*/){
		   	   	
		   	   
			#]
			
			replyTo ticketrequest with ticketaccepted  : ticketaccepted(valid)
			
			[# } 
			   else{
			   	
			   	
			#] 
			
			replyTo ticketrequest with ticketrejected  : ticketrejected(invalid)
			[# } #] 
			 
			    					
	  	}
		
		
	}
	Goto waitclientrequest
	
	State elabLoadDone{
		//gestione del caso in cui il peso da depositare del truck è maggiore rispetto alla capacità massima di peso trasportabile dal trolley
		onMsg( loaddone : loaddone(FW)){
			[# val foodWeight = payloadArg(0)
					
			#]
			//forward transporttrolley -m domove:domove(indoor)
		}
	}
	Transition t2 whenTime 2500 -> moveRobotHome
				  whenRequest loaddone -> elabLoadDone
	
	State moveRobotHome{
		
	}
	Goto waitclientrequest
	
	
	
}



/*QActor fridgetruck context ctxfridgetruck{ //SCOMPARE
	State s0 initial{
		println("fridgetruck starts") color red
	}
}*/




