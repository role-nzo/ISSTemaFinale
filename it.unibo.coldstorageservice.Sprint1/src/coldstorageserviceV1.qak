System coldstorageservice

Request engage        : engage(ARG) //FATTO
Reply   engagedone    : engagedone(ARG) //FATTO
Reply   engagerefused : engagerefused(ARG) //FATTO

Dispatch disengage : disengage(ARG) //FATTO

Request  doplan   : doplan( PATH, OWNER, STEPTIME )
Reply doplandone  : doplandone( ARG )
Reply doplanfailed  : doplanfailed( PLANDONE, PLANTODO )


Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG)
Reply moverobotfailed:  moverobotfailed(ARG)


Dispatch domove : domove(TARGET) //FATTO


//Ottenimento del ticket
Request newticket		: newticket( FW )
Reply newticketaccepted : newticketaccepted( TICKET )
Reply newticketrefused  : newticketrefused( REASON )


//Show ticket per rilascio merce
Request ticketrequest : ticketrequest( TICKET, FW )
Reply ticketaccepted  : ticketaccepted( MESSAGE )
Reply ticketrejected  : ticketrejected( REASON )


Request loaddone	: loaddone(FW)
Reply chargetaken	: chargetaken(MESSAGE)
Reply chargefailure : chargefailure(REASON)


Context ctxbasicrobot 		  ip [host="127.0.0.1" port=8020]
Context ctxcoldstorageservice ip [host="localhost" port=8022]
//Context ctxfridgetruck 		  ip [host="192.168.10.122" port=8023] //Eliminare -> funziona solo con 3 contesti

ExternalQActor basicrobot context ctxbasicrobot

/*
 * TO-DO
 * Scrivere sullo sprint i ragionamenti fatti per raggiungere il modello
 * Scrivere perchè coldRoom POJO (non ha la necessità di inviare/ricevere messaggi direttamente)
 * Problema del load-time lungo -> perchè abbiamo scelto più messaggi per la showTicketRequest
 * 
 * PROBLEMA DRIVER MALEVOLO: come riconoscere il truck
 * 		--> non necessario
 * PROBLEMA CODA SHOW TICKET: come gestire il caso di più show ticket request
 * 		--> da testare
 * 
 * Nell'analisi del problema indicare:
 *  - Struttura ticket: idTruck,
 *  -  Perchè coldRoom come POJO e non Attore
 *  - Come abbiamo risolto problema del load time lungo
 *  - Problema carico maggiore rispetto al peso trasportabile
 * 
 */


QActor transporttrolley context ctxcoldstorageservice{
	
	[#  val planner = unibo.planner23.Planner23Util()
    val MyName    = name //upcase var
    //val MapName   = "mapEmpty23"
    val MapName = "mapCompleteWithObst23ok"
    val StepTime  = 200 //Era 345
    var Plan      = ""
    var TargetX   = ""
    var TargetY   = ""
    var Position = "" //Sapere posizione del robot da modificare su doMove (necessario sapere verso che direzione si muove il robot)
#]
	
	State s0 initial{
		discardMsg Off //We want store the non-handled messages
		
		println("transporttrolley starts") color blue
		//Acquisizione del basicrobot
    	request basicrobot -m engage : engage( $MyName )
	}
	
	Transition t0 whenReply engagedone    -> init
                  whenReply engagerefused -> waitrobotfree
                  
    State waitrobotfree{
		println("transporttrolley engage refused") color red
        request basicrobot -m moverobot : moverobot(1,5)	
	}
	
	State init{
		[#
           Plan = planner.planForGoal(""+1,""+6).toString()
           Plan = planner.planCompacted(Plan) //Ottengo la stringa delle mosse da fare in forma compatta 
        #]
        request basicrobot -m doplan : doplan($Plan, worker, $StepTime)	
		
		
			
		[# planner.initAI() //Per prendere il planner
	    planner.loadRoomMap(MapName) //Chiedo al planner di caricare la mappa
	    planner.showMap() //Chiedo al planner di visualizzare la mappa
	  #]
	} Goto waitclientrequest
	
	State waitclientrequest{
	  
	  println("$name | waiting the client request...")
	  
	}
	Transition t0 whenMsg domove  -> elabMove
	 
	State elabMove{
		
		onMsg( domove : domove(ARG) ){
		    [# val dest = payloadArg(0)
		    	//TODO 	
		    	
		  	#]
		  	println("${dest}")
		    
		    /*
		    [#   Plan = planner.planForGoal(""+0,""+0).toString()
               Plan = planner.planCompacted(Plan) //Ottengo la stringa delle mosse da fare in forma compatta 
		
		    #]  */
		    //request basicrobot -m doplan : doplan($Plan, worker, $StepTime)
		  }
		
		
	}
	Transition t0 whenReply doplandone  -> planFinish
				 
	
	State elabGoToIndoor{
		println("moveTheRobot to Indoor")
		printCurrentMessage color blue
            [#
               Plan = planner.planForGoal(""+1,""+6).toString()
               Plan = planner.planCompacted(Plan) //Ottengo la stringa delle mosse da fare in forma compatta 
            #]
        request basicrobot -m doplan : doplan($Plan, worker, $StepTime)	
	}
	
	
	
	State elabClientRequest{
	  onMsg( moverobot : moverobot(X,Y)){
	    [# TargetX = payloadArg(0)
	      TargetY = payloadArg(1)
	      #]
	  }
	}
	Goto planTheRobotmoves
	
	State planTheRobotmoves{
		println("moveTheRobot to $TargetX $TargetY")
		printCurrentMessage color blue
            [#
               Plan = planner.planForGoal(""+TargetX,""+TargetY).toString()
               Plan = planner.planCompacted(Plan) //Ottengo la stringa delle mosse da fare in forma compatta 
            #]
        request basicrobot -m doplan : doplan($Plan, worker, $StepTime)
	}
	Transition t0 whenReply doplandone   -> endok
              	  whenReply doplanfailed -> endko
              	  
    State endok{
	  //Aggiorno la posizone del robot sulla mappa
	  [# planner.doPathOnMap(Plan) #]
	  [# planner.showCurrentRobotState(); #]
	  replyTo moverobot with moverobotdone : moverobotdone(ok)
	}
	
	State endko{
		onMsg( doplanfailed : doplanfailed(ARG) ){
		    [# val PathTodo = payloadArg(0) #]
		    println("pos NOT reached - PathTodo = ${PathTodo} vs. $Plan") color red
		    println("${Plan.substring(0, Plan.lastIndexOf(PathTodo))}") color blue
		    [#   val PathDone = Plan.substring(0, Plan.lastIndexOf(PathTodo))
		
		    #]
		    [# planner.doPathOnMap(PathDone) #]
		    [# planner.showCurrentRobotState(); #]
		    replyTo moverobot with moverobotfailed : moverobotfailed($PathDone,$PathTodo)
		  }
	}
	
	State stopped{
		
	}
	
	State resumed{
		
	}
	
	State planFinish{
		//Position = coldRoom invia deposit
		//home si gira faccia in basso
		//indoor invia charge taken	
		
	}
		
}


QActor coldstorageservice context ctxcoldstorageservice{ //Registrata a coldRoom
	[# val ticketList = listOf<Ticket>() 
	   val currentWeight = 0 
	   val maxWeight = 100
	#]
	//currentWeight rappresenta il peso virtuale corrente della coldRoom che considera anche i ticket ancora in coda
	
	State s0 initial{
		
		
		
		
		println("coldstorageservice starts") color green
		
	}
	Goto waitclientrequest
	
	
	State waitclientrequest{
	  
	  println("$name | waiting the client request...")
	  
	}
	Transition t0 whenRequest newticket -> elabNewTicket
				  whenRequest ticketrequest  -> elabTicketRequest
				  whenRequest loaddone -> elabLoadDone
	
	State elabNewTicket{
		[#
			val ticket = Ticket("aaa", java.time.Instant.now().epochSecond, 3)
		#]
		//Verifica id univoco, il ticket verrà aggiunto ad una lista di ticket
		replyTo newticket with newticketaccepted:newticketaccepted(aaa)
		
		
	}
	Goto waitclientrequest
	
	State elabTicketRequest{
		
		onMsg( ticketrequest : ticketrequest( TICKET, FW )){
	    	[# val currentTime = java.time.Instant.now().epochSecond 
		   	   val idTicket = payloadArg(0)
		   	   
		   	   for (ticket in ticketList){
		   	   	  //ciclo for per trovare il biglietto del driver nella lista
		   	   }
		   	   
		   	   //val ticketValid = (currentTime - ticket.creationTime) > TIMEMAX
		   	   if(true /*ticketValid*/){
		   	   	
		   	   
			#]
			
			replyTo ticketrequest with ticketaccepted  : ticketaccepted(valid)
			
			[# } 
			   else{
			   	
			   	
			#] 
			
			replyTo ticketrequest with ticketrejected  : ticketrejected(invalid)
			[# } #] 
			 
			    					
	  	}
		
		
	}
	Goto waitclientrequest
	
	State elabLoadDone{
		//gestione del caso in cui il peso da depositare del truck è maggiore rispetto alla capacità massima di peso trasportabile dal trolley
		onMsg( loaddone : loaddone(FW)){
			[# val foodWeight = payloadArg(0)
					
			#]
			forward transporttrolley -m domove:domove(indoor)
		}
	}
	Transition t2 whenTime 2500 -> moveRobotHome
				  whenRequest loaddone -> elabLoadDone
	
	State moveRobotHome{
		
	}
	Goto waitclientrequest
	
	
	
}



/*QActor fridgetruck context ctxfridgetruck{ //SCOMPARE
	State s0 initial{
		println("fridgetruck starts") color red
	}
}*/




