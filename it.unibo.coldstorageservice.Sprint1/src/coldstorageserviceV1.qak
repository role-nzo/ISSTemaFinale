System coldstorageservice

Request engage        : engage(OWNER) //FATTO
Reply   engagedone    : engagedone(ARG) //FATTO
Reply   engagerefused : engagerefused(ARG) //FATTO

Dispatch disengage    : disengage(ARG) //FATTO

Dispatch setrobotstate: setpos(X,Y,D)
Dispatch setdirection : dir( D )  //D =up|down!left|right

Request  doplan   : doplan( PATH, OWNER, STEPTIME )
Reply doplandone  : doplandone( ARG )
Reply doplanfailed  : doplanfailed( PLANDONE, PLANTODO )


Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG)
Reply moverobotfailed:  moverobotfailed(ARG)


Dispatch goMoveToIndoor   : goMoveToIndoor(_) //FATTO
Dispatch goMoveToColdRoom : goMoveToColdRoom(_) //FATTO
Dispatch goMoveToHome     : goMoveToHome(_) //FATTO


//Ottenimento del ticket
Request newticket		: newticket( FW )
Reply newticketaccepted : newticketaccepted( TICKET )
Reply newticketrefused  : newticketrefused( REASON )


//Show ticket per rilascio merce
Request ticketrequest : ticketrequest( TICKET, FW )
Reply ticketaccepted  : ticketaccepted( MESSAGE )
Reply ticketrejected  : ticketrejected( REASON )


Request loaddone	: loaddone(FW)
Reply chargetaken	: chargetaken(MESSAGE)
Reply chargefailure : chargefailure(REASON)


Request waitLoad : waitLoad(_)
Reply waitLoadDone : waitLoadDone(_)

Dispatch deposit : deposit(_)
Dispatch updatevirtualweight : updatevirtualweight(FW)

Request clearColdRoom : clearColdRoom(_)
Reply coldRoomCleared : coldRoomCleared(_)





Context ctxbasicrobot 		  ip [host="127.0.0.1" port=8020] 
Context ctxcoldstorageservice ip [host="127.0.0.1" port=8022]
Context ctxfridgetruck 		  ip [host="127.0.0.1" port=8023] //Eliminare -> funziona solo con 3 contesti
Context ctxfridgetrucktemp 	  ip [host="localhost" port=8024] //Eliminare -> funziona solo con 3 contesti

ExternalQActor basicrobot context ctxbasicrobot

/*
 * TO-DO
 * Scrivere sullo sprint i ragionamenti fatti per raggiungere il modello
 * Scrivere perchè coldRoom POJO (non ha la necessità di inviare/ricevere messaggi direttamente)
 * Problema del load-time lungo -> perchè abbiamo scelto più messaggi per la showTicketRequest
 * 
 * PROBLEMA DRIVER MALEVOLO: come riconoscere il truck
 * 		--> non necessario
 * PROBLEMA CODA SHOW TICKET: come gestire il caso di più show ticket request
 * 		--> da testare
 * 
 * Nell'analisi del problema indicare:
 *  - Struttura ticket: idTruck,
 *  -  Perchè coldRoom come POJO e non Attore
 *  - Come abbiamo risolto problema del load time lungo
 *  - Problema carico maggiore rispetto al peso trasportabile
 * 
 */


/*
 * 
 * PROBLEMA FRIDGE TRUCK:
 * TcpMsgHandler  | ERROR: A term starting with 0-9 cannot be parsed as a number
 * dipende dal ticket che comincia con un intero
 * 		
 */
 
 
/*
 * TODO:
 * 1. gestione svuotamento periodico cold room: il peso reale viene azzerato mentre quello virtuale sarà "virtual - real" (il risultato sarà pari al peso dei ticket validi non ancora gestiti)
 * 2. gestione elaborazione ticket: delega a ticketservice (FATTO)
 */
 
 /*
  * TODO:
  * scrivere motivazioni per l'implementazione dell'attore "ticketservice"
  * 	es: sempre disponibile per la creazione di nuovi ticket
  */
  /*TODO:
   * abbiamo introdotto un peso virtuale in modo da distinguere il peso effettivo all'interno della ColdRoom dal peso totale delle richieste di ticket
   *
   * 
   */

QActor transporttrolley context ctxcoldstorageservice{
	//TODO: gestire il move failed 
	
	State s0 initial {
		println("transporttrolley starts") color blue
		//Acquisizione del basicrobot
    	request basicrobot -m engage : engage(transporttrolley)	
	}
	Transition t0 whenReply engagedone    -> init
                  whenReply engagerefused -> waitrobotfree
                  
    State waitrobotfree{
		println("transporttrolley engage refused") color blue
	}
	
	State init{
		println("transporttrolley init") color blue
	} Goto waitcoldstorageservicerequest
	
	
	State waitcoldstorageservicerequest {
	  println("$name | waiting the client request...") color blue
	}
	Transition t0 whenMsg goMoveToIndoor   -> elabMoveIndoor
				  whenMsg goMoveToColdRoom -> elabMoveColdRoom
				  whenMsg goMoveToHome     -> elabMoveHome
	 
	State elabMoveIndoor {	
		printCurrentMessage color blue	
		
		request basicrobot -m moverobot	: moverobot(0, 4)
	}
	Transition t0 whenReply moverobotdone -> planFinishIndoor
				  whenReply moverobotfailed -> waitcoldstorageservicerequest
	
	State elabMoveColdRoom {
		printCurrentMessage color blue
        
        request basicrobot -m moverobot	: moverobot(4, 3)	
	}
	Transition t0 whenReply moverobotdone -> planFinishColdRoom
				  whenReply moverobotfailed -> waitcoldstorageservicerequest
	
	State elabMoveHome {
		printCurrentMessage color blue

        request basicrobot -m moverobot	: moverobot(0, 0)		
	}
	Transition t0 whenReply moverobotdone -> planFinishHome
				  whenReply moverobotfailed -> waitcoldstorageservicerequest

	
	State stopped {
		
	}
	
	State resumed {
		
	}
	
	State planFinishIndoor {
		//prendere il carico
		
		println("$name | at Indoor") color blue
		delay 3000
	} Transition t1 whenRequest waitLoad -> elabWaitLoad
	
	State planFailedIndoor {
		//prendere il carico
		
		println("$name | at Indoor") color blue
		delay 3000
	} Transition t1 whenRequest waitLoad -> elabWaitLoad
	
	State elabWaitLoad {
		replyTo waitLoad with waitLoadDone  : waitLoadDone(valid)
	} Goto elabMoveColdRoom
	
	State planFinishColdRoom {
		//depositare il carico
		
		println("$name | at ColdRoom") color blue
		delay 3000
		forward coldstorageservice -m deposit : deposit(0)
		
	} Goto waitcoldstorageservicerequest
	
	State planFinishHome {
		
		println("$name | at home") color blue
		delay 1000
		
		//NON FUNZIONA
		//forward basicrobot -m setdirection : dir(down)
	    
	    
		//aspettare altre richieste
	} Goto waitcoldstorageservicerequest
		
}

QActor emptycoldroom context ctxcoldstorageservice{
	
	State s0 initial{
		request coldstorageservice -m clearColdRoom : clearColdRoom(0)
		println("$name | richiesta svuotamento coldroom")
		delay 7000
	}Goto s0
		
}

QActor ticketservice context ctxcoldstorageservice {
	
	[# var ticketList = mutableListOf<Ticket>() 
	   var currentWeightVirtual = 0 
	   var maxWeight = 100
	   var TimeMax = 300
	#]
	
	State s0 initial{
		println("$name | wait for request") color yellow
	}
	Transition t0 whenRequest newticket -> elabNewTicket
				  whenRequest ticketrequest  -> elabTicketRequest
				  whenMsg updatevirtualweight -> elabUpdateVirtualWeight
	

	State elabNewTicket{
		
		println("$name | elab new ticket") color yellow
		
		onMsg( newticket : newticket( FW )){
			
			[#
			
			var fw = payloadArg(0).toInt()
			if(currentWeightVirtual + fw <= maxWeight){
				currentWeightVirtual += fw
				var Id = Ticket.getRandomId() 
				var found = false
				while(found){
				found = false
				
					for (t in ticketList){
						if(t.id==Id){
							Id = Ticket.getRandomId()
							found = true
							break
						}
					}
				}
				
				var ticket = Ticket(Id, java.time.Instant.now().epochSecond, fw)
				
				ticketList.add(ticket)
				
				println(ticket)
				
			
				#] replyTo newticket with newticketaccepted:newticketaccepted( $Id ) [#
				} else {
				#] replyTo newticket with newticketrefused:newticketrefused( Peso ) [#
				}
			#]
		}
		
		
		//Verifica id univoco, il ticket verrà aggiunto ad una lista di ticket
		
		
		
	}
	Goto s0
	
	State elabUpdateVirtualWeight{
			println("$name | virtual weight update") color yellow
			
			onMsg( updatevirtualweight : updatevirtualweight(FW)){
				[#
					currentWeightVirtual = currentWeightVirtual - payloadArg(0).toInt()
				#]
			}
			println("$name | current virtual weight: $currentWeightVirtual") color yellow
	}Goto s0
	
	State elabTicketRequest{
		
		println("$name | elab ticket request") color yellow
		
		onMsg( ticketrequest : ticketrequest( TICKET, FW )) {
			[#
				val currentTime = java.time.Instant.now().epochSecond 
		   	   	val idTicket = payloadArg(0)
		   	   	val foodWeight = payloadArg(1).toInt()
		   	   
		   	   	var ticket : Ticket? = null
		   	   
		   	   	for (t in ticketList) {
					//ciclo for per trovare il biglietto del driver nella lista
		   	   	  	if(t.id == idTicket) {
		   	   	  	
		   	   	  		ticket = t
		   	   	  		break
		   	   	  	}
		   	   	}
		   	   
		   	   	if(ticket==null) { 
		   	   		println("Not found")
	   	   			#]
		   	   		replyTo ticketrequest with ticketrejected  : ticketrejected(invalid)
		   	   		[#
		   	   	} else {   
			   	  	
				   	if(foodWeight<ticket!!.fw){
						currentWeightVirtual -= (ticket!!.fw-foodWeight)
				   	}
				   	   
					ticketList.remove(ticket)
				   	   
					println(currentTime - ticket!!.creationTime)
				   	   
					if((currentTime - ticket!!.creationTime) < TimeMax) {	
				   	   	println("ticket valid")	
			   	   		#]
						replyTo ticketrequest with ticketaccepted  : ticketaccepted(valid)
						[#
					} else{
						currentWeightVirtual -= ticket!!.fw
						#]
						replyTo ticketrequest with ticketrejected  : ticketrejected(invalid)		 
			  			[#
			  		}
		  		}
  			#]	  	
		}		
	}
	Goto s0
}



QActor coldstorageservice context ctxcoldstorageservice{ //Registrata a coldRoom
	
	[# var CurrentWeightReal = 0
	   var CurrentTicketFW = 0
	#]

	//currentWeight rappresenta il peso virtuale corrente della coldRoom che considera anche i ticket ancora in coda
	
	State s0 initial{
		println("coldstorageservice starts") color green
		
		delegate "newticket" to ticketservice
				
	}
	Goto waitclientrequest
	
	
	State waitclientrequest{
	  println("$name | waiting the client request...") color green
	 
	}
	Transition t0 whenRequest ticketrequest  -> elabTicketRequest
				  whenRequest clearColdRoom  -> elabClearColdRoom
	
	State elabTicketRequest {
		onMsg( ticketrequest : ticketrequest( TICKET, FW )) {
			[# 
		   	   	val IDTicket = payloadArg(0)
		   	   	val FoodWeight = payloadArg(1)   	
		   	#]
		   	
		   	request ticketservice -m ticketrequest : ticketrequest( $IDTicket, $FoodWeight )
	   	}
	}
	Transition t1 whenReply ticketaccepted -> elabTicketAccepted
				  whenReply ticketrejected -> elabTicketRejected
				  
	
	State elabTicketAccepted {
		replyTo ticketrequest with ticketaccepted  : ticketaccepted(valid)
	} Goto waitLoadDoneRequest
	
	State elabTicketRejected {
		replyTo ticketrequest with ticketrejected  : ticketrejected(invalid)		
	} Goto waitclientrequest
	
	
	State waitLoadDoneRequest{
		println("$name | wait load request") color green
		
	}
	Transition t2 whenRequest loaddone -> elabLoadDone
	
	State elabLoadDone {
		
		println("$name | elab load done") color green
		
		//gestione del caso in cui il peso da depositare del truck è maggiore rispetto alla capacità massima di peso trasportabile dal trolley
		onMsg( loaddone : loaddone(FW)) {
			[# 
					CurrentTicketFW = payloadArg(0).toInt()
			#]
			forward transporttrolley -m goMoveToIndoor   : goMoveToIndoor(0)
			request transporttrolley -m waitLoad : waitLoad(0)
			//TODO: transportrolley deve andare da solo in coldRoom dopo essere andato in Indoor e prelevato
			
			
		}
	}
	Transition t3 whenReply waitLoadDone -> elabWaitDeposit
	 
	
	State elabWaitDeposit {
		//Invio charge taken fridge truck 
		println("$name | elab wait load done") color green
	}
	Transition t4 whenMsg deposit -> elabDeposit
	
	
	State elabDeposit {
		println("$name | elab deposit") color green
		
		[#
			CurrentWeightReal += CurrentTicketFW	
		#]
		
		println("Deposit - Current weight real: $CurrentWeightReal") color green
		
		replyTo loaddone with chargetaken : chargetaken(0) 
	}
	Transition t5 whenTime 2500 -> moveRobotHome
				  whenRequest ticketrequest  -> elabTicketRequest
				  
	
	State moveRobotHome {
		
		forward transporttrolley -m goMoveToHome     : goMoveToHome(0)
		
	}
	Goto waitclientrequest
	
	State elabClearColdRoom{
		println("$name | empty coldRoom") color green
		
		forward ticketservice -m updatevirtualweight : updatevirtualweight($CurrentWeightReal)
		
		[#
			CurrentWeightReal = 0	
		#]
		println("$name | coldRoom cleared - current weight real: $CurrentWeightReal") color green
		replyTo clearColdRoom with coldRoomCleared : coldRoomCleared(0)
	
	}Goto waitclientrequest
	
	
}



QActor fridgetruck context ctxfridgetruck{ //SCOMPARE
	
	State s0 initial {
		println("fridgetruck starts") color red
		request coldstorageservice -m newticket		: newticket( 3 )
	}
	Transition t0 whenReply newticketaccepted -> elabTicketAccepted
	
	State elabTicketAccepted {
		
		
		onMsg( newticketaccepted : newticketaccepted(TICKET)){
			[# 
				var CurrentTicketId = payloadArg(0)
				println(CurrentTicketId)
			#]
			
			request coldstorageservice -m ticketrequest : ticketrequest($CurrentTicketId, 3)
		}
	}
	Transition t1 whenReply ticketaccepted -> elabLoadDone
				  //whenReply ticketrejected -> s0
	
	State elabLoadDone {
		request coldstorageservice -m loaddone : loaddone( 3 )
	}
	Transition t1 whenReply chargetaken -> elabChargeTaken
	
	State elabChargeTaken {
		
	}
	
}

QActor fridgetrucktemp context ctxfridgetrucktemp{ //SCOMPARE
	
	State s0 initial {
		println("fridgetruck starts") color red
		delay 3000
		request coldstorageservice -m newticket		: newticket( 97 )
	}
	Transition t0 whenReply newticketaccepted -> elabTicketAccepted
	
	State elabTicketAccepted {
		
		onMsg( newticketaccepted : newticketaccepted(TICKET)){
			[# 
				var CurrentTicketId = payloadArg(0)
				println(CurrentTicketId)
			#]
			
			request coldstorageservice -m ticketrequest : ticketrequest($CurrentTicketId, 97)
		}
	}
	Transition t1 whenReply ticketaccepted -> elabLoadDone
				  //whenReply ticketrejected -> s0
	
	State elabLoadDone {
		request coldstorageservice -m loaddone : loaddone( 97 )
	}
	Transition t1 whenReply chargetaken -> elabChargeTaken
	
	State elabChargeTaken {
		
	}
	
}




